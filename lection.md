
# Объяснение рекурсии на примере чисел Фибоначчи
Алгоритм быстрой сортировки (QuickSort) является одним из наиболее эффективных алгоритмов сортировки. Вот как он работает на примере данной реализации:

Выбирается опорный элемент (pivot). В данной реализации он выбирается как первый элемент массива (array[0]).
Создаются два подмассива: один содержит элементы, меньшие или равные опорному элементу (less), а другой содержит элементы, большие опорного элемента (greater).
Рекурсивно вызывается алгоритм QuickSort для подмассивов less и greater.
Когда длина подмассивов становится меньше или равна 1, они возвращаются как отсортированные массивы.
На последнем этапе сортированные подмассивы less и greater конкатенируются с опорным элементом между ними.
Пример:

Исходный массив: [1, 3, 7, 9, 4, 33, 7, 90]

Опорный элемент: 1
Меньшие элементы: [1] (ничего нет)
Большие элементы: [3, 7, 9, 4, 33, 7, 90]
Вызываем рекурсивно для less (ничего не происходит, так как длина равна 1) и greater.
В greater:
Опорный элемент: 3
Меньшие элементы: [3] (ничего нет)
Большие элементы: [7, 9, 4, 33, 7, 90]
Рекурсивные вызовы для less и greater.
Процесс повторяется до тех пор, пока длина массива не станет меньше или равной 1.
Когда рекурсия вернется, элементы объединяются в правильном порядке с опорным элементом между ними.
Итоговый отсортированный массив: [1, 3, 4, 7, 7, 9, 33, 90]

# Описание передачи данных из локального репо на github 

Чтобы выложить все задачи из Visual Studio Code на GitHub из локальной папки, вам нужно выполнить несколько шагов:

Создание репозитория на GitHub:

Зайдите на сайт GitHub и войдите в свой аккаунт.
Нажмите на кнопку "New" в правом верхнем углу экрана.
Введите имя репозитория, выберите настройки (например, публичный или приватный) и нажмите кнопку "Create repository".
Инициализация репозитория локально:

Откройте командную строку или терминал в папке с вашими файлами.
Выполните команду git init, чтобы инициализировать локальный репозиторий.
Добавление файлов в индекс Git:

Выполните команду git add ., чтобы добавить все файлы из текущей директории в индекс Git. Если вы хотите добавить только определенные файлы, укажите их имена вместо ..
Фиксация изменений:

Выполните команду git commit -m "Initial commit" для фиксации изменений с сообщением о коммите.
Связь локального репозитория с удаленным:

Скопируйте URL вашего нового репозитория на GitHub.
Выполните команду git remote add origin <URL_репозитория>, чтобы связать ваш локальный репозиторий с удаленным на GitHub.
Отправка изменений на GitHub:

Выполните команду git push -u origin master, чтобы отправить изменения на GitHub. Если вы используете другую ветку, укажите ее вместо master.
После выполнения этих шагов все ваши файлы из Visual Studio Code будут загружены на GitHub в новый репозиторий. В дальнейшем, при внесении изменений в файлы, вы можете использовать команды git add, git commit и git push для обновления репозитория на GitHub.

# Объяснение рекурсии наглядно на возведении числа в степень
мы используем умножение для постепенного умножения числа a на себя b раз (для положительной степени) или на обратное значение f(a, -b-1) (для отрицательной степени).

Давайте разберем, как работает функция f(3, 4):

f(3, 4) вычисляется как 3 * f(3, 3).
f(3, 3) вычисляется как 3 * f(3, 2).
f(3, 2) вычисляется как 3 * f(3, 1).
f(3, 1) вычисляется как 3 * f(3, 0).
f(3, 0) возвращает 1 (по определению базового случая).
Теперь подставляем значения обратно: f(3, 1) становится 3 * 1 = 3.
f(3, 2) становится 3 * 3 = 9.
f(3, 3) становится 3 * 9 = 27.
И, наконец, f(3, 4) становится 3 * 27 = 81.
Таким образом, функция f(3, 4) правильно вычисляет 3 в степени 4 и возвращает 81.

# Объяснение рекурсии наглядно на сумме чисел
Давайте разберем пример на основе функции sum(a, b), используя числа a = 5 и b = 3.

Первый вызов функции sum(5, 3):

b положительное, поэтому мы увеличиваем a на 1 и уменьшаем b на 1, вызывая рекурсивно функцию sum(6, 2).
Второй вызов функции sum(6, 2):

b также положительное, поэтому мы снова увеличиваем a на 1 и уменьшаем b на 1, вызывая рекурсивно функцию sum(7, 1).
Третий вызов функции sum(7, 1):

b по-прежнему положительное, поэтому мы еще раз увеличиваем a на 1 и уменьшаем b на 1, вызывая рекурсивно функцию sum(8, 0).
Четвертый вызов функции sum(8, 0):

b равно 0, поэтому мы возвращаем a, что равно 8.
Таким образом, сумма чисел a = 5 и b = 3 равна 8, что правильно вычисляется с помощью рекурсивной функции sum(a, b).

## Вариант ошибки рекурсии в сумме
Если вы измените шаг на 2 в вашей функции sum(a + 2, b - 2), то рекурсивные вызовы также должны отражать этот шаг. Вот как это может выглядеть:

python
Copy code
def sum(a, b):
    if b == 0:
        return a
    elif b > 0:
        return sum(a + 2, b - 2)
    else:
        return sum(a - 2, b + 2)

Пример использования функции:
a = 5
b = 3
result = sum(a, b)
print(result)  # Выведет: 11
Теперь рассмотрим пример на основе чисел a = 5 и b = 3:

Первый вызов функции sum(5, 3):

b положительное, поэтому мы увеличиваем a на 2 и уменьшаем b на 2, вызывая рекурсивно функцию sum(7, 1).
Второй вызов функции sum(7, 1):

b по-прежнему положительное, поэтому мы снова увеличиваем a на 2 и уменьшаем b на 2, вызывая рекурсивно функцию sum(9, -1).
Третий вызов функции sum(9, -1):

b теперь отрицательное, поэтому мы уменьшаем a на 2 и увеличиваем b на 2, вызывая рекурсивно функцию sum(7, 1).
Четвертый вызов функции sum(7, 1):

Мы снова находимся в том же месте, что и во втором вызове, и процесс продолжится по тому же пути.
Это будет цикл, который будет вызываться бесконечно, так как каждый раз мы переключаемся между увеличением и уменьшением на 2. Такое решение не приведет к ожидаемому результату, и рекурсия будет продолжаться до того момента, пока не будет достигнута максимальная глубина рекурсии, после чего произойдет ошибка переполнения стека.

## Смена директории
* os.chdir(path) - смена текущей директории.
import os
os.chdir('C:/Users/79190/PycharmProjects/GB')
* os.getcwd() - текущая рабочая директория
import os
print(os.getcwd()) # 'C:\Users\79190\PycharmProjects\webproject'
14
* os.path - является вложенным модулем в модуль os и реализует некоторые
полезные функции для работы с путями, такие как:
○ os.path.basename(path) - базовое имя пути

